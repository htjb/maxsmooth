%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{maxsmooth Documentation}
\date{Jan 23, 2020}
\release{0.0.0}
\author{Harry Thomas Jones Bevins}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{source/index::doc}}



\chapter{Introduction}
\label{\detokenize{source/intro:introduction}}\begin{quote}\begin{description}
\item[{maxsmooth}] \leavevmode
maximally smooth function fitting

\item[{Author}] \leavevmode
Harry Thomas Jones Bevins

\item[{Version}] \leavevmode
0.0.0

\item[{Homepage}] \leavevmode
\sphinxurl{https://github.com/htjb/maxsmooth}

\end{description}\end{quote}

\sphinxcode{\sphinxupquote{maxsmooth}} is an open source software for fitting maximally smooth functions
,hearafter MSFs, to data sets. MSFs are functions for which there are no
inflection points or, in other words, the high order derivatives do not cross
zero within the domain of interest. They are designed to prevent the loss of
signals when fitting out dominant foregrounds and in some cases can be used to
highlight systematics left in the data.

You can read more about MSFs here ..

\sphinxcode{\sphinxupquote{maxsmooth}} uses quadratic programming implemented with \sphinxcode{\sphinxupquote{cvxopt}} to fit
data subject to a linear constraint. The constraint on an MSF can be codefied
like so,
\begin{equation*}
\begin{split}\frac{d^m~y}{d~x^m}~>~0~~\textnormal{or}~~\frac{d^m~y}{d~x^m}~<~0.\end{split}
\end{equation*}
This constraint is itself not linear but \sphinxcode{\sphinxupquote{maxsmooth}} is designed to test the
constraint,
\begin{equation*}
\begin{split}\pm \frac{d^m~y}{d~x^m}~<~0\end{split}
\end{equation*}
where a positive sign infront of the \(m^{th}\) order derivative forces the derivative
to be negative for all x. For an \(N^{th}\) order polynomial \sphinxcode{\sphinxupquote{maxsmooth}} tests
every combination of possible signs in front of the derivatives with \(m~>2\) for
\(N~<=~10\). For \(N~>~10\) a smaller subset of the ‘sign\sphinxhyphen{}space’ is
tested to reduce runtime but sufficiently large subset to return an accurate
fit.

\sphinxcode{\sphinxupquote{maxsmooth}} features a built in library of maximally smooth functions or
allows the user to define their own. The addition of possible inflection points
is also available to the user. The software has been designed with these two
applications in mind and is a simple interface.


\section{Instalation}
\label{\detokenize{source/intro:instalation}}

\section{Dependencies}
\label{\detokenize{source/intro:dependencies}}
Basic requirements:
\begin{itemize}
\item {} 
Python version..

\item {} 
\sphinxhref{https://pypi.org/project/pylab/}{pylab}

\item {} 
\sphinxhref{https://pypi.org/project/numpy/}{numpy}

\item {} 
\sphinxhref{https://pypi.org/project/cvxopt/}{cvxopt}

\end{itemize}


\section{Citation}
\label{\detokenize{source/intro:citation}}

\chapter{maxsmooth}
\label{\detokenize{source/maxsmooth:maxsmooth}}\label{\detokenize{source/maxsmooth::doc}}

\section{smooth}
\label{\detokenize{source/maxsmooth:module-maxsmooth.msf}}\label{\detokenize{source/maxsmooth:smooth}}\index{maxsmooth.msf (module)@\spxentry{maxsmooth.msf}\spxextra{module}}\index{smooth (class in maxsmooth.msf)@\spxentry{smooth}\spxextra{class in maxsmooth.msf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/maxsmooth:maxsmooth.msf.smooth}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{maxsmooth.msf.}}\sphinxbfcode{\sphinxupquote{smooth}}}{\emph{x}, \emph{y}, \emph{N}, \emph{setting}, \emph{**kwargs}}{}
\sphinxstylestrong{Parameters:}
\begin{quote}

x: \sphinxstyleemphasis{numpy.array} The x data points for the set being fitted.

y: \sphinxstyleemphasis{numpy.array} The y data points for fitting.

N: \sphinxstyleemphasis{list} The number of terms in the MSF polynomial function.

setting: \sphinxstyleemphasis{class atributes} The settings determined by
\sphinxtitleref{maxsmooth.settings.setting} and called before smooth().
\end{quote}

\sphinxstylestrong{Kwargs:}
\begin{quote}
\begin{description}
\item[{initial\_params: \sphinxstyleemphasis{list of length N} Allows the user to overwrite the}] \leavevmode
the default initial parameters which are a list of length N given
by,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{params0} \PYG{o}{=} \PYG{o}{[}\PYG{o}{(}self.y\PYG{o}{[}\PYGZhy{}1\PYG{o}{]}\PYGZhy{}self.y\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]}\PYG{o}{)}/2\PYG{o}{]}*\PYG{o}{(}self.N\PYG{o}{)}
\end{sphinxVerbatim}

or equivalently in log\sphinxhyphen{}space for the ‘logarithmic\_polynomial’
model\_type(see Settings),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{params0} \PYG{o}{=} \PYG{o}{[}\PYG{o}{(}np.log10\PYG{o}{(}self.y\PYG{o}{[}\PYGZhy{}1\PYG{o}{]}\PYG{o}{)}\PYGZhy{}np.log10\PYG{o}{(}self.y\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]}\PYG{o}{)}\PYG{o}{)}/2\PYG{o}{]} *
    \PYG{o}{(}self.N\PYG{o}{)}
\end{sphinxVerbatim}

\end{description}
\end{quote}

\end{fulllineitems}



\section{Settings}
\label{\detokenize{source/maxsmooth:module-maxsmooth.settings}}\label{\detokenize{source/maxsmooth:settings}}\index{maxsmooth.settings (module)@\spxentry{maxsmooth.settings}\spxextra{module}}
The Settings class is used to define options that are passed to maxsmooth.
It should be called by the user before the function \sphinxcode{\sphinxupquote{smooth}} by,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
from maxsmooth.settings import setting
\PYG{n+nv}{setting} \PYG{o}{=} setting\PYG{o}{(}\PYG{o}{)}
\end{sphinxVerbatim}

and changes to the settings can be made before a call to \sphinxcode{\sphinxupquote{smooth}}
like so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
setting.model\PYGZus{}type \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}polynomial\PYGZsq{}}
\end{sphinxVerbatim}
\index{setting (class in maxsmooth.settings)@\spxentry{setting}\spxextra{class in maxsmooth.settings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/maxsmooth:maxsmooth.settings.setting}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{maxsmooth.settings.}}\sphinxbfcode{\sphinxupquote{setting}}}~\begin{quote}\begin{description}
\item[{Attributes}] \leavevmode\begin{description}
\item[{\sphinxstylestrong{fit\_type: (Default==’qp\sphinxhyphen{}sign\_flipping’)}}] \leavevmode
\item[{\sphinxstylestrong{The type of fitting routine used to fit the model. There are two options}}] \leavevmode
\item[{\sphinxstylestrong{designed to explore the sign space of the function.}}] \leavevmode
\item[{\sphinxstylestrong{Accepted options:}}] \leavevmode
\item[{\sphinxstylestrong{‘qp’ \sphinxhyphen{} Quadratic programming testing every combination of sign}}] \leavevmode
on the derivatives. This is a quick process provided the
order of the polynomial is small and the data
sets being fitted are also small.

\item[{\sphinxstylestrong{‘qp\sphinxhyphen{}sign\_flipping’ \sphinxhyphen{} Quadratic Programming testing a sub}}] \leavevmode
sample of sign combinations on the derivatives. The
algorithm currently generates a random set of signs for
the N\sphinxhyphen{}2 derivatives. It then flips sucessive signs in the
list until it calculates a chi squared smaller than the
previous evaluation of the objective function. For
example a 4th order polynomial has 2 derivatives with m\textgreater{}=2
which means it has 4 sign combinations {[}1,1{]},{[}\sphinxhyphen{}1,\sphinxhyphen{}1{]},{[}\sphinxhyphen{}1,1{]}
and {[}1,\sphinxhyphen{}1{]}. On first random generation we get {[}\sphinxhyphen{}1,1{]} with
which we evaluate the objective function. We then flip the
first sign and evaluate again with {[}1,1{]}. If need be we
then go back to the original list and flip the second sign
evaluating with {[}\sphinxhyphen{}1,\sphinxhyphen{}1{]}. The process repeats until the new
chi squared is no longer smaller than the previous
evaluation.( I don’t think this process ever repeats more
times than there are signs to flip). We then repeat the
entire process a set number of times to ensure we can
identify the true minimum. The number of repeats needed
is dependent on the polynomial order. High polynomial
orders require a larger number of repeats to find the true
minimum. Currently the number of repeats is set at
2*(N\sphinxhyphen{}2)**2. The sucess of this method can be judged by
running with the ‘qp’ method.

\item[{\sphinxstylestrong{model\_type: (Default = ‘normalised\_polynomial’) The type of model used}}] \leavevmode
to fit the data.
Accepted options:
\begin{quote}
\begin{description}
\item[{‘normalised\_polynomial’ \sphinxhyphen{} This is a polynomial of the form}] \leavevmode
y=y\_0*sum(p\_i*(x/x\_0)**i). It consistently appears to give
the best fit.

\item[{‘polynomial’ \sphinxhyphen{} This is a polynomial of the form}] \leavevmode
y=sum(p\_i*(x)**i).

\item[{‘MSF\_2017\_polynomial’ \sphinxhyphen{} This is a polynomial of the form}] \leavevmode
described in section 4 of doi:10.3847/1538\sphinxhyphen{}4357/aa69bd.

\item[{‘logarithmic\_polynomial’ \sphinxhyphen{} This is a polynomial model}] \leavevmode
similar to that used with the setting ‘polynomial’ but
solved in log\sphinxhyphen{}space. It has the form
log\_\{10\}(y)=sum(p\_i*(log\_\{10\}(x))**i). NOTE this model
will not work if the y values are negative, for example in
the case of uncalibrated data.

\item[{‘user\_defined’ \sphinxhyphen{} Allows the user to implement their own}] \leavevmode
maximally smooth function to fit to the data.

\end{description}
\end{quote}

\item[{\sphinxstylestrong{base\_dir: (Default = ‘Fitted\_Output’) This is the}}] \leavevmode
directory in which the resultant graphs of the fit, derivatives
and residuals are saved. When testing multiple model types it is
recommended to include this in the base directory
name eg self.base\_dir= ‘{\color{red}\bfseries{}Data\_Name\_}’ + self.model\_type + ‘/’.

\item[{\sphinxstylestrong{cvxopt\_maxiter: (Default=1000) The maximum number of iterations for}}] \leavevmode
the cvxopt quadratic programming routine.

\item[{\sphinxstylestrong{filtering: (Default=True) Generally for high order N there will be}}] \leavevmode
combinations of sign for which cvxopt cannot find a solution and
these terminate with the error “Terminated (Singular KKT Matrix)”.
Setting filtering to True will flag this as a warning and exclude
these sign combinations when determining the best possible fit.
Setting filtering to False will cause the program to crash with
the error.

\item[{\sphinxstylestrong{all\_output: (Default=False) If set to True this will output the results}}] \leavevmode
of each run of cvxopt to the terminal.

\item[{\sphinxstylestrong{ifp: (Default = False) Setting equal to True allows for inflection}}] \leavevmode\begin{description}
\item[{points in the m order derivatives listed in ifp\_derivatives.}] \leavevmode\begin{description}
\item[{NOTE: The algorithm will not necessarily return derivatives}] \leavevmode
with inflection points if this is set to True.

\end{description}

NOTE: Allowing for inflection points will increasese run time.

\end{description}

\item[{\sphinxstylestrong{ifp\_list: (Default = ‘None’) The list of derivatives you wish to allow}}] \leavevmode
to have inflection points in(see ifp above). This should be a list
of derivative orders eg. if I have a fith order
polynomial and I wish to allow the the second derivative to have
an inflection point then ifp\_list={[}2{]}. If I wished to allow the
second and fourth derivative to have inflection points
I would write ifp\_list={[}2,4{]}. Values in ifp\_list cannot exceed N\sphinxhyphen{}2.

\item[{\sphinxstylestrong{data\_save: (Default = True) Setting data\_save to True will save sample}}] \leavevmode
graphs of the derivatives, fit and residuals. The inputs to
produce these graphs are all outputted from the msf\_fit function
and they can be reproduced with more specific axis labels/units in
the users code. If filtering is also set to True, which it is by
default, then parameters,objective function values and sign
combinations from each successful run of cvxopt will be saved
to the base directories in seperate folders. The condition on
filtering prevents saving data from runs of cvxopt that did not
find solutions and terminated with a singular KKT matrix.

\end{description}

\end{description}\end{quote}

\end{fulllineitems}



\section{Designing A Basis Function}
\label{\detokenize{source/maxsmooth:designing-a-basis-function}}

\section{Errors and Warnings}
\label{\detokenize{source/maxsmooth:errors-and-warnings}}

\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{maxsmooth.msf}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.msf}}
\item\relax\sphinxstyleindexentry{maxsmooth.settings}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.settings}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}