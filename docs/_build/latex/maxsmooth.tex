%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{maxsmooth Documentation}
\date{Jun 29, 2020}
\release{1.0.0}
\author{Harry Thomas Jones Bevins}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{source/index::doc}}



\chapter{Introduction}
\label{\detokenize{source/intro:introduction}}\begin{quote}\begin{description}
\item[{maxsmooth}] \leavevmode
maximally smooth function fitting

\item[{Author}] \leavevmode
Harry Thomas Jones Bevins

\item[{Version}] \leavevmode
1.0.0

\item[{Homepage}] \leavevmode
\sphinxurl{https://github.com/htjb/maxsmooth}

\end{description}\end{quote}

\sphinxcode{\sphinxupquote{maxsmooth}} is an open source software for fitting derivative constrained
functions, DCFs such as Maximally Smooth Functions
, MSFs to data sets. MSFs are functions for which there are no zero
crossings in derivatives of order \(m \geq 2\) within the domain of interest.
They are designed to prevent the loss of
signals when fitting out dominant foregrounds and in some cases can be used to
highlight systematics left in the data. More generally for DCFs the minimum
constrained derivative order, m can take on any value or a set of
specific high order derivatives can be constrained.

You can read more about MSFs here ..

\sphinxcode{\sphinxupquote{maxsmooth}} uses quadratic programming implemented with \sphinxcode{\sphinxupquote{cvxopt}} to fit
data subject to a linear constraint. The constraint on an MSF can be codefied
like so,
\begin{equation*}
\begin{split}\frac{d^m~y}{d~x^m}~\geq~0~~\textnormal{or}~~\frac{d^m~y}{d~x^m}~\leq~0.\end{split}
\end{equation*}
This constraint is itself not linear but \sphinxcode{\sphinxupquote{maxsmooth}} is designed to test the
constraint,
\begin{equation*}
\begin{split}\pm \frac{d^m~y}{d~x^m}~\leq~0\end{split}
\end{equation*}
where a positive sign infront of the \(m^{th}\) order derivative forces the derivative
to be negative for all x. For an \(N^{th}\) order polynomial \sphinxcode{\sphinxupquote{maxsmooth}} can test
every available sign combination but by default it implements a ‘sign\sphinxhyphen{}smapling’
algorithm. This is detailed in the \sphinxcode{\sphinxupquote{maxsmooth}} paper (see citation) but is summarised
below.

The available sign combinations act as discrete parameter spaces all with
global minima and \sphinxcode{\sphinxupquote{maxsmooth}} is capable of finding the minimum of these global
minima by implementing a descent algorithm which is followed by a directional
exploration. The descent routine typically finds an approximate to the global
minimum and then the directional exploration is a complete search
of the sign combinations in the neighbourhood
of that minimum. The searched region is limited by factors
that encapsulate enough of the neighbourhood to confidently return the global minimum.

The sign sampling method is reliant on the problem being ‘well defined’ but this
is not always the case and it is in these instances possible to run the code testing
every available sign combination on the constrained derivatives. For a definition of
a ‘well defined’ problem and it’s counter part see the \sphinxcode{\sphinxupquote{maxsmooth}} paper.

\sphinxcode{\sphinxupquote{maxsmooth}} features a built in library of DCFs or
allows the user to define their own. The addition of possible inflection points
and zero crossings in higher order derivatives is also available to the user.
The software has been designed with these two
applications in mind and is a simple interface.


\section{Instalation}
\label{\detokenize{source/intro:instalation}}

\section{Documentation}
\label{\detokenize{source/intro:documentation}}
The documentation can be compiled from the git repository by…


\section{Dependencies}
\label{\detokenize{source/intro:dependencies}}
Basic requirements:
\begin{itemize}
\item {} 
Python version..

\item {} 
\sphinxhref{https://pypi.org/project/matplotlib/}{matplotlib}

\item {} 
\sphinxhref{https://pypi.org/project/numpy/}{numpy}

\item {} 
\sphinxhref{https://pypi.org/project/cvxopt/}{cvxopt}

\end{itemize}


\section{Citation}
\label{\detokenize{source/intro:citation}}

\chapter{maxsmooth Example Codes}
\label{\detokenize{source/maxsmooth:maxsmooth-example-codes}}\label{\detokenize{source/maxsmooth::doc}}
This section is designed to introduce the user to the software and the form
in which it is run. It provides basic examples of data fitting with a built in
MSF model and a user defined model.

There are also examples of functions that can be used pre\sphinxhyphen{}fitting and post\sphinxhyphen{}fitting
for various purposes including; determination of the best DCF model from the
built in library for the problem being fitted, analysis of the \({\chi^2}\)
distribution as a function of the discrete sign spaces and analysis of the
parameter space surrounding the optimum results.


\section{Simple Example code}
\label{\detokenize{source/maxsmooth:simple-example-code}}
In order to run the \sphinxcode{\sphinxupquote{maxsmooth}} software using the built
in DCF models for a simple fit the user can follow the simple structure detailed here.

The user should begin by importing the \sphinxtitleref{smooth} class from \sphinxtitleref{maxsmooth.DCF}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{maxsmooth}\PYG{n+nn}{.}\PYG{n+nn}{DCF} \PYG{k+kn}{import} \PYG{n}{smooth}
\end{sphinxVerbatim}

The user should then import the data they wish to fit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data/x.npy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data/y.npy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

and define the polynomial orders they wish to fit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
N = [3, 4, 5, 6, 7, 8, 9, 10, 11]
for i in range(len(N)):
    `act on N[i]`
\end{sphinxVerbatim}

or for example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10}
\end{sphinxVerbatim}

\sphinxtitleref{smooth} can be called like so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result} \PYG{o}{=} \PYG{n}{smooth}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{kwargs}\PYG{p}{)}
\end{sphinxVerbatim}

where the kwargs are detailed below. It’s resulting attributes can be accessed by writing
\sphinxcode{\sphinxupquote{result.attribute\_name}}. For example printing the outputs is done like
so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Objective Funtion Evaluations:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{optimum\PYGZus{}chi}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{RMS:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{rms}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Parameters:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{optimum\PYGZus{}params}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Fitted y:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{y\PYGZus{}fit}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Sign Combinations:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{optimum\PYGZus{}signs}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Derivatives:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{result}\PYG{o}{.}\PYG{n}{derivatives}\PYG{p}{)}
\end{sphinxVerbatim}


\section{New Basis Example}
\label{\detokenize{source/maxsmooth:new-basis-example}}

\section{Best Basis Example}
\label{\detokenize{source/maxsmooth:best-basis-example}}

\section{\protect\({\chi^2}\protect\) Distribution Example}
\label{\detokenize{source/maxsmooth:chi-2-distribution-example}}
This example will show you how to generate a plot of the \({\chi^2}\)
distribution as a function of the descrete sign combinations on the constrained
derivatives.

First you will need to import your data and fit this using \sphinxcode{\sphinxupquote{maxsmooth}} as
was done in the simple example code.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}

\PYG{n}{x} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data/x.npy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{y} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{load}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Data/y.npy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k+kn}{from} \PYG{n+nn}{maxsmooth}\PYG{n+nn}{.}\PYG{n+nn}{DCF} \PYG{k+kn}{import} \PYG{n}{smooth}

\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{smooth}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{y}\PYG{p}{,} \PYG{n}{N}\PYG{p}{,} \PYG{n}{base\PYGZus{}dir}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{examples/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
  \PYG{n}{data\PYGZus{}save}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{fit\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

Here we have used some additional keyword arguments for the ‘smooth’ fitting
function. ‘data\_save’ ensures that the files containing the tested sign combinations
and the corresponding objective function evaluations exist in the base directory
which we have changed to ‘base\_dir=’examples/’’. These files are essential for
the plotting the \({\chi^2}\) distribution and are not saved by \sphinxcode{\sphinxupquote{maxsmooth}}
without ‘data\_save=True’. We have also set the ‘fit\_type’ to ‘qp’ rather than the
default ‘qp\sphinxhyphen{}sign\_flipping’. This ensures that all of the available sign
combinations are tested rather than a sampled set giving us a full picture of the
distribution when we plot it. We have used the default DCF model to fit this data.

We can import the ‘chi\_plotter’ like so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{maxsmooth}\PYG{n+nn}{.}\PYG{n+nn}{chidist\PYGZus{}plotter} \PYG{k+kn}{import} \PYG{n}{chi\PYGZus{}plotter}
\end{sphinxVerbatim}

and produce the fit which gets placed in the base directory with the following
code,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{chi\PYGZus{}plotter}\PYG{p}{(}\PYG{n}{N}\PYG{p}{,} \PYG{n}{base\PYGZus{}dir}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{examples/}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{fit\PYGZus{}type}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{qp}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

We pass the same ‘base\_dir’ as before so that the plotter can find the correct output
files. We also give the function the same ‘fit\_type’ used for the fitting which
ensures that the files can be read.

The reultant plot is shown below and this can be used to determine how well
the sign sampling approach using a descent and directional exploration
can find the global minimum. If the distribution looks like noise then it is
unlikely the sign sampling algorithm will consistently find the global minimum.
Rather it will likely repeatedly return the local minima found after the descent
algorithm and you should use the ‘qp’ method testing all available sign combinations
in any future fits to the data with this DCF model.

The distribution for the above problem is shown below where the global minimum
is shown as a yellow star.

\noindent{\hspace*{\fill}\sphinxincludegraphics[width=400\sphinxpxdimen]{{chi_distribution}.png}\hspace*{\fill}}


\section{Parameter Plotter Example}
\label{\detokenize{source/maxsmooth:parameter-plotter-example}}

\chapter{Maxsmooth Functions}
\label{\detokenize{source/maxsmooth:maxsmooth-functions}}
This section details the specifics of the built in functions in \sphinxcode{\sphinxupquote{maxsmooth}} including
the relevant key word arguments and default parameters for all.


\section{smooth()}
\label{\detokenize{source/maxsmooth:smooth}}\phantomsection\label{\detokenize{source/maxsmooth:module-maxsmooth.DCF}}\index{maxsmooth.DCF (module)@\spxentry{maxsmooth.DCF}\spxextra{module}}
\sphinxstyleemphasis{smooth} is used to call the fitting routine. There are a number
of **kwargs that can be assigned to the function which change how the fit is
performed, the model that is fit and  various other attributes. These are
detailed below.
\index{smooth (class in maxsmooth.DCF)@\spxentry{smooth}\spxextra{class in maxsmooth.DCF}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/maxsmooth:maxsmooth.DCF.smooth}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{maxsmooth.DCF.}}\sphinxbfcode{\sphinxupquote{smooth}}}{\emph{x}, \emph{y}, \emph{N}, \emph{**kwargs}}{}
\sphinxstylestrong{Parameters:}
\begin{quote}

x: \sphinxstylestrong{numpy.array} The x data points for the set being fitted.

y: \sphinxstylestrong{numpy.array} The y data points for fitting.

N: \sphinxstylestrong{int} The number of terms in the MSF polynomial function.
\end{quote}

\sphinxstylestrong{Kwargs:}
\begin{quote}
\begin{description}
\item[{fit\_type: \sphinxstylestrong{Default = ‘qp\sphinxhyphen{}sign\_flipping’} This kwarg allows the user to}] \leavevmode
switch between sampling the available discrete sign spaces (default)
or testing all sign combinations on the derivatives which can be
accessed by setting to ‘qp’.

\item[{model\_type: \sphinxstylestrong{Default = ‘difference\_polynomials’} Allows the user to}] \leavevmode
access default Derivative Constrained Functions built into the
software. Available options include the default, ‘polynomial’,
‘normalised\_polynomial’, ‘legendre’, ‘log\_polynomial’,
‘loglog\_polynomial’ and ‘exponential’. For more details on the
functional form of the built in basis see the \sphinxcode{\sphinxupquote{maxsmooth}} paper.

\item[{pivot\_point: \sphinxstylestrong{Default = len(x)//2 else integer} Some of the built in}] \leavevmode
models rely on pivot points in the data sets which by defualt is
set as the middle index. This can be altered via this kwarg which
can occasionally lead to a better quality fit.

\item[{base\_dir: \sphinxstylestrong{Default = ‘Fitted\_Output/’} The location of the outputted}] \leavevmode
data from \sphinxcode{\sphinxupquote{maxsmooth}}. This must be a string and end in ‘/’. If the
file does not exist then \sphinxcode{\sphinxupquote{maxsmooth}} will creat it. By default the
only outputted data is a summary of the best fit but additional data
can be recorded by setting the keyword argument ‘data\_save = True’.

\item[{data\_save: \sphinxstylestrong{Default = False} By setting this to True the algorithm}] \leavevmode
will save every tested set of parameters, signs and objective
function evaluations into files in base\_dir. Theses files will be
over written on repeated runs but they are needed to run the
‘chidist\_plotter’.

\item[{all\_output: \sphinxstylestrong{Default = False} If set to True this outputs to the}] \leavevmode
terminal every fit performed by the algorithm. By default the only
output is the optimal solution once the code is finished.

\item[{cvxopt\_maxiter: \sphinxstylestrong{Default = 10000 else integer} This shouldn’t need}] \leavevmode
changing for most problems however if cvxopt fails with a ‘maxiters
reached’ error message this can be increased. Doing so arbitrarily
will however increase the run time of \sphinxcode{\sphinxupquote{maxsmooth}}.

\item[{initial\_params: \sphinxstylestrong{Default = None else list of length N} Allows the user}] \leavevmode
to overwrite the default initial parameters used by cvxopt.

\item[{constraints: \sphinxstylestrong{Default = 2 else an integer less than or equal to N \sphinxhyphen{} 1}}] \leavevmode
The minimum constrained derivative order which is set by default to
2 for a Maximally Smooth Function.

\item[{ifp\_list: \sphinxstylestrong{Default = None else list of integers} Allows you to}] \leavevmode
specify if the conditions should be relaxed on any
of the derivatives between constraints and the highest order
derivative. e.g. a 6th order fit with just a constrained 2nd and 3rd
order derivative would have an ifp\_list = {[}4, 5{]}.

\item[{cap: \sphinxstylestrong{Default = (len(available\_signs)//N) + N else an integer}}] \leavevmode
Determines the maximum number of signs explored either side of the
minimum :math\textasciigrave{}\{chi\textasciicircum{}2\}\textasciigrave{} value found after the decent algorithm
has terminated.

\item[{chi\_squared\_limit: \sphinxstylestrong{Default = 2*min(chi\_squared) else float or int}}] \leavevmode
The maximum allowed increase in :math\textasciigrave{}\{chi\textasciicircum{}2\}\textasciigrave{} during the
directional exploration. If this value is exceeded then the
exploration in one direction is terminated and started in the other.
For more details on this and ‘cap’ see the \sphinxcode{\sphinxupquote{maxsmooth}} paper.

\end{description}

The following Kwargs can be used by the user to define thier own basis
function and will overwrite the ‘model\_type’ kwarg.
\begin{description}
\item[{basis\_function: \sphinxstylestrong{Default = None else function with parameters}}] \leavevmode
\sphinxstylestrong{(x, y, pivot\_point, N)} This is a function of basis functions
for the quadratic programming. The variable pivot\_point is the
index at the middle of the datasets x and y by default but can
be adjusted.

\item[{model: \sphinxstylestrong{Default = None else function with parameters}}] \leavevmode
\sphinxstylestrong{(x, y, pivot\_point, N, params)} This is
a user defined function describing the model to be fitted to the
data.

\item[{der\_pres: \sphinxstylestrong{Default = None else function with parameters}}] \leavevmode
\sphinxstylestrong{(m, i, x, y, pivot\_point)}
This function describes the prefactors on the ith term of the mth
order derivative used in defining the constraint.

\item[{derivatives: \sphinxstylestrong{Default = None else function with parameters}}] \leavevmode
\sphinxstylestrong{(m, i, x, y, pivot\_point, params)}
User defined function describing the ith term of the mth
order derivative used to check that conditions are being met.

\item[{args: \sphinxstylestrong{Default = None else list} of extra arguments for \sphinxtitleref{smooth}}] \leavevmode
to pass to the functions detailed above.

\end{description}
\end{quote}

\sphinxstylestrong{Output}
\begin{quote}

If N is a list with length greater than 1 then the outputs from smooth
are lists and arrays with dimension 0 equal to len(N).
\begin{description}
\item[{.y\_fit:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The fitted arrays of y data from \sphinxtitleref{smooth}.

\item[{.optimum\_chi:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The optimum chi squared values for the fit calculated
by,
\begin{equation*}
\begin{split}{X^2=\sum(y-y_{fit})^2}.\end{split}
\end{equation*}
\item[{.optimum\_params:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The set of parameters corresponding to the optimum
fits.

\item[{.rms:}] \leavevmode
\sphinxstyleemphasis{list} The rms value of the residuals \({y_{res}=y-y_{fit}}\)
calculated by,
\begin{equation*}
\begin{split}{rms=\sqrt{\frac{\sum(y-y_{fit})^2}{n}}}\end{split}
\end{equation*}
where \(n\) is the number of data points.

\item[{.derivatives:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The \(m^{th}\) order derivatives.

\item[{.optimum\_signs:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The sign combinations corresponding to the
optimal results.

\end{description}
\end{quote}

\end{fulllineitems}



\section{best\_basis()}
\label{\detokenize{source/maxsmooth:module-maxsmooth.best_basis}}\label{\detokenize{source/maxsmooth:best-basis}}\index{maxsmooth.best\_basis (module)@\spxentry{maxsmooth.best\_basis}\spxextra{module}}

\section{chidist\_plotter()}
\label{\detokenize{source/maxsmooth:module-maxsmooth.chidist_plotter}}\label{\detokenize{source/maxsmooth:chidist-plotter}}\index{maxsmooth.chidist\_plotter (module)@\spxentry{maxsmooth.chidist\_plotter}\spxextra{module}}
This function allows the user to produce plots of the \({\chi^2}\)
distribution as a function of the available discrete sign spaces for the
constrained derivatives. This can be used to identify whether or not the
problem is \sphinxtitleref{ill defined}, see the \sphinxcode{\sphinxupquote{maxsmooth}} paper for a definition,
and if it can be solved using the sign sampling approach.

It can also be used to determine whether or not the ‘cap’ and maximum allowed
increase on the value of \({\chi^2}\) during the directional exploration
are sufficient to identify the global minimum for the problem.

The function is reliant on the output of the \sphinxcode{\sphinxupquote{maxsmooth}} ‘smooth’ function
which can be saved using the ‘data\_save = True’ kwarg when running ‘smooth’.
\index{chi\_plotter (class in maxsmooth.chidist\_plotter)@\spxentry{chi\_plotter}\spxextra{class in maxsmooth.chidist\_plotter}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/maxsmooth:maxsmooth.chidist_plotter.chi_plotter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{maxsmooth.chidist\_plotter.}}\sphinxbfcode{\sphinxupquote{chi\_plotter}}}{\emph{N}, \emph{**kwargs}}{}~
\end{fulllineitems}



\section{parameter\_plotter()}
\label{\detokenize{source/maxsmooth:parameter-plotter}}

\section{Errors and Warnings}
\label{\detokenize{source/maxsmooth:errors-and-warnings}}

\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{maxsmooth.best\_basis}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.best_basis}}
\item\relax\sphinxstyleindexentry{maxsmooth.chidist\_plotter}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.chidist_plotter}}
\item\relax\sphinxstyleindexentry{maxsmooth.DCF}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.DCF}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}