%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{maxsmooth Documentation}
\date{Jan 24, 2020}
\release{0.0.0}
\author{Harry Thomas Jones Bevins}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{source/index::doc}}



\chapter{Introduction}
\label{\detokenize{source/intro:introduction}}\begin{quote}\begin{description}
\item[{maxsmooth}] \leavevmode
maximally smooth function fitting

\item[{Author}] \leavevmode
Harry Thomas Jones Bevins

\item[{Version}] \leavevmode
0.0.0

\item[{Homepage}] \leavevmode
\sphinxurl{https://github.com/htjb/maxsmooth}

\end{description}\end{quote}

\sphinxcode{\sphinxupquote{maxsmooth}} is an open source software for fitting maximally smooth functions
,hearafter MSFs, to data sets. MSFs are functions for which there are no
inflection points or, in other words, the high order derivatives do not cross
zero within the domain of interest. They are designed to prevent the loss of
signals when fitting out dominant foregrounds and in some cases can be used to
highlight systematics left in the data.

You can read more about MSFs here ..

\sphinxcode{\sphinxupquote{maxsmooth}} uses quadratic programming implemented with \sphinxcode{\sphinxupquote{cvxopt}} to fit
data subject to a linear constraint. The constraint on an MSF can be codefied
like so,
\begin{equation*}
\begin{split}\frac{d^m~y}{d~x^m}~>~0~~\textnormal{or}~~\frac{d^m~y}{d~x^m}~<~0.\end{split}
\end{equation*}
This constraint is itself not linear but \sphinxcode{\sphinxupquote{maxsmooth}} is designed to test the
constraint,
\begin{equation*}
\begin{split}\pm \frac{d^m~y}{d~x^m}~<~0\end{split}
\end{equation*}
where a positive sign infront of the \(m^{th}\) order derivative forces the derivative
to be negative for all x. For an \(N^{th}\) order polynomial \sphinxcode{\sphinxupquote{maxsmooth}} tests
every combination of possible signs in front of the derivatives with \(m~>2\) for
\(N~<=~10\). For \(N~>~10\) a smaller subset of the ‘sign\sphinxhyphen{}space’ is
tested to reduce runtime but sufficiently large subset to return an accurate
fit.

\sphinxcode{\sphinxupquote{maxsmooth}} features a built in library of maximally smooth functions or
allows the user to define their own. The addition of possible inflection points
is also available to the user. The software has been designed with these two
applications in mind and is a simple interface.


\section{Instalation}
\label{\detokenize{source/intro:instalation}}

\section{Dependencies}
\label{\detokenize{source/intro:dependencies}}
Basic requirements:
\begin{itemize}
\item {} 
Python version..

\item {} 
\sphinxhref{https://pypi.org/project/pylab/}{pylab}

\item {} 
\sphinxhref{https://pypi.org/project/numpy/}{numpy}

\item {} 
\sphinxhref{https://pypi.org/project/cvxopt/}{cvxopt}

\end{itemize}


\section{Citation}
\label{\detokenize{source/intro:citation}}

\chapter{maxsmooth}
\label{\detokenize{source/maxsmooth:maxsmooth}}\label{\detokenize{source/maxsmooth::doc}}

\section{Simple Example code}
\label{\detokenize{source/maxsmooth:simple-example-code}}
This section is designed to introduce the user to the software and the form
in which it is run. In order to run the \sphinxtitleref{maxsmooth} software using the built
in MSFs the user can follow the simple structure detailed here.

The user should begin by importing the \sphinxtitleref{setting} class from
\sphinxtitleref{maxsmooth.settings} and the \sphinxtitleref{smooth} class from \sphinxtitleref{maxsmooth.msf}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
from maxsmooth.settings import setting
from maxsmooth.msf import smooth
\end{sphinxVerbatim}

The \sphinxtitleref{setting} class is used to alter the outputs, model type, fit type,
base directory and other attributes of the \sphinxtitleref{smooth} class which is called
upon to do the fitting.

The settings of \sphinxtitleref{smooth} should be generated at the start of the code and the
attributes changed immediately bellow (see settings for more details).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{setting} \PYG{o}{=} setting\PYG{o}{(}\PYG{o}{)}
setting.data\PYGZus{}save \PYG{o}{=} True
setting.all\PYGZus{}output \PYG{o}{=} True
\end{sphinxVerbatim}

The user should then import the data they wish to fit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
import numpy as np

\PYG{n+nv}{x} \PYG{o}{=} np.load\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Data/x.npy\PYGZsq{}}\PYG{o}{)}
\PYG{n+nv}{y} \PYG{o}{=} np.load\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Data/y.npy\PYGZsq{}}\PYG{o}{)}
\end{sphinxVerbatim}

and define the polynomial orders they wish to fit as a list.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{N} \PYG{o}{=} \PYG{o}{[}\PYG{l+m}{3}, \PYG{l+m}{4}, \PYG{l+m}{5}, \PYG{l+m}{6}, \PYG{l+m}{7}, \PYG{l+m}{8}, \PYG{l+m}{9}, \PYG{l+m}{10}, \PYG{l+m}{11}\PYG{o}{]}
\end{sphinxVerbatim}

or for example,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{N} \PYG{o}{=} \PYG{o}{[}\PYG{l+m}{10}\PYG{o}{]}
\end{sphinxVerbatim}

\sphinxtitleref{smooth} can be called like so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{result} \PYG{o}{=} smooth\PYG{o}{(}x, y, N, setting\PYG{o}{)}
\end{sphinxVerbatim}

and it’s resulting attributes can be accessed by writing
\sphinxcode{\sphinxupquote{result.attribute\_name}}. For example printing the outputs is done like
so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
print\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Objective Funtion Evaluations:\PYGZbs{}n\PYGZsq{}}, result.Optimum\PYGZus{}chi\PYG{o}{)}
print\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}RMS:\PYGZbs{}n\PYGZsq{}}, result.rms\PYG{o}{)}
print\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Parameters:\PYGZbs{}n\PYGZsq{}}, result.Optimum\PYGZus{}params\PYG{o}{)}
print\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Fitted y:\PYGZbs{}n\PYGZsq{}}, result.y\PYGZus{}fit\PYG{o}{)}
print\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Sign Combinations:\PYGZbs{}n\PYGZsq{}}, result.Optimum\PYGZus{}signs\PYG{o}{)}
print\PYG{o}{(}\PYG{l+s+s1}{\PYGZsq{}Derivatives:\PYGZbs{}n\PYGZsq{}}, result.derivatives\PYG{o}{)}
\end{sphinxVerbatim}


\section{smooth}
\label{\detokenize{source/maxsmooth:module-maxsmooth.msf}}\label{\detokenize{source/maxsmooth:smooth}}\index{maxsmooth.msf (module)@\spxentry{maxsmooth.msf}\spxextra{module}}
\sphinxstyleemphasis{smooth} is used to call the fitting routine by the user.
\index{smooth (class in maxsmooth.msf)@\spxentry{smooth}\spxextra{class in maxsmooth.msf}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/maxsmooth:maxsmooth.msf.smooth}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{maxsmooth.msf.}}\sphinxbfcode{\sphinxupquote{smooth}}}{\emph{x}, \emph{y}, \emph{N}, \emph{setting}, \emph{**kwargs}}{}
\sphinxstylestrong{Parameters:}
\begin{quote}

x: \sphinxstyleemphasis{numpy.array} The x data points for the set being fitted.

y: \sphinxstyleemphasis{numpy.array} The y data points for fitting.

N: \sphinxstyleemphasis{list} The number of terms in the MSF polynomial function.

setting: \sphinxstyleemphasis{class atributes} The settings determined by
\sphinxtitleref{maxsmooth.settings.setting} and called before smooth().
\end{quote}

\sphinxstylestrong{Kwargs:}
\begin{quote}
\begin{description}
\item[{initial\_params: \sphinxstyleemphasis{list of length N} Allows the user to overwrite the}] \leavevmode
the default initial parameters which are a list of length N given
by,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{params0} \PYG{o}{=} \PYG{o}{[}\PYG{o}{(}self.y\PYG{o}{[}\PYGZhy{}1\PYG{o}{]}\PYGZhy{}self.y\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]}\PYG{o}{)}/2\PYG{o}{]}*\PYG{o}{(}self.N\PYG{o}{)}
\end{sphinxVerbatim}

or equivalently in log\sphinxhyphen{}space for the ‘logarithmic\_polynomial’
model\_type(see Settings),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{params0} \PYG{o}{=} \PYG{o}{[}\PYG{o}{(}np.log10\PYG{o}{(}self.y\PYG{o}{[}\PYGZhy{}1\PYG{o}{]}\PYG{o}{)}\PYGZhy{}np.log10\PYG{o}{(}self.y\PYG{o}{[}\PYG{l+m}{0}\PYG{o}{]}\PYG{o}{)}\PYG{o}{)}/2\PYG{o}{]} *
    \PYG{o}{(}self.N\PYG{o}{)}
\end{sphinxVerbatim}

\end{description}

The following Kwargs can be used by the user to define thier own basis
function. {\color{red}\bfseries{}**}Further details on the structures of the following matrix
and functions can be found in the section \sphinxtitleref{Designing A Basis Function}.
**
\begin{description}
\item[{data\_matrix: \sphinxstyleemphasis{CVXOPT dense matrix of dimensions (len(y),1)} The data}] \leavevmode
matrix is a matrix of y values to be fitted by cvxopt.
The default data matrix used by \sphinxstyleemphasis{smooth} is,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{b} \PYG{o}{=} matrix\PYG{o}{(}y, \PYG{o}{(}len\PYG{o}{(}y\PYG{o}{)}, \PYG{l+m}{1}\PYG{o}{)}, \PYG{l+s+s1}{\PYGZsq{}d\PYGZsq{}}\PYG{o}{)}.
\end{sphinxVerbatim}

See CVXOPT documentation for details on building a dense matrix.
This will only need to be changed on rare occasions when the
fitting space is changed. For example smooth will automatically
adjust this matrix to,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nv}{b} \PYG{o}{=} matrix\PYG{o}{(}np.log10\PYG{o}{(}y\PYG{o}{)}, \PYG{o}{(}len\PYG{o}{(}y\PYG{o}{)}, \PYG{l+m}{1}\PYG{o}{)}, \PYG{l+s+s1}{\PYGZsq{}d\PYGZsq{}}\PYG{o}{)},
\end{sphinxVerbatim}

when model\_type is set to ‘logarithmic\_polynomial’ (see settings).

\item[{basis\_function: \sphinxstyleemphasis{function with parameters (x, y, mid\_point, N)} This is}] \leavevmode
a function of basis functions for the quadratic programming.
The variable mid\_point is the index at the middle of the datasets
x and y.

\item[{model: \sphinxstyleemphasis{function with parameters (x, y, mid\_point, N, params)} This is}] \leavevmode
a user defined function describing the model to be fitted to the
data.

\item[{der\_pres: \sphinxstyleemphasis{function with parameters (m, i, x, y, mid\_point)}}] \leavevmode
This function describes the prefactors on the ith term of the mth
order derivative used in defining the constraint.

\item[{derivatives: \sphinxstyleemphasis{function with parameters (m, i, x, y, mid\_point, params)}}] \leavevmode
User defined function describing the ith term of the mth
order derivative used to check that conditions are being met.

\item[{args: \sphinxstyleemphasis{list} of extra arguments for \sphinxtitleref{smooth} to pass to the functions}] \leavevmode
detailed above.

\end{description}
\end{quote}

\sphinxstylestrong{Output}
\begin{quote}

If N is a list with length greater than 1 then the outputs from smooth
are lists and arrays with dimension 0 equal to len(N).
\begin{description}
\item[{y\_fit:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The fitted arrays of y data from \sphinxtitleref{smooth}.

\item[{Optimum\_chi:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The optimum chi squared values for the fit calculated
by,
\begin{equation*}
\begin{split}{X^2=\sum(y-y_{fit})^2}.\end{split}
\end{equation*}
\item[{Optimum\_params:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The set of parameters corresponding to the optimum
fits.

\item[{rms:}] \leavevmode
\sphinxstyleemphasis{list} The rms value of the residuals \({y_{res}=y-y_{fit}}\)
calculated by,
\begin{equation*}
\begin{split}{rms=\sqrt{\frac{\sum(y-y_{fit})^2}{n}}}\end{split}
\end{equation*}
where \(n\) is the number of data points.

\item[{derivatives:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The \(m^{th}\) order derivatives.

\item[{Optimum\_signs:}] \leavevmode
\sphinxstyleemphasis{numpy.array} The sign combinations corresponding to the
optimal results.

\end{description}
\end{quote}

\end{fulllineitems}



\section{settings}
\label{\detokenize{source/maxsmooth:module-maxsmooth.settings}}\label{\detokenize{source/maxsmooth:settings}}\index{maxsmooth.settings (module)@\spxentry{maxsmooth.settings}\spxextra{module}}
The Settings class is used to define options that are passed to maxsmooth.
It should be called by the user before the function \sphinxcode{\sphinxupquote{smooth}} by,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
from maxsmooth.settings import setting
\PYG{n+nv}{setting} \PYG{o}{=} setting\PYG{o}{(}\PYG{o}{)}
\end{sphinxVerbatim}

and changes to the settings can be made before a call to \sphinxcode{\sphinxupquote{smooth}}
like so,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
setting.model\PYGZus{}type \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}polynomial\PYGZsq{}}
\end{sphinxVerbatim}
\index{setting (class in maxsmooth.settings)@\spxentry{setting}\spxextra{class in maxsmooth.settings}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{source/maxsmooth:maxsmooth.settings.setting}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{maxsmooth.settings.}}\sphinxbfcode{\sphinxupquote{setting}}}
\sphinxstylestrong{Attributes}

\sphinxstylestrong{fit\_type:} (Default==’qp\sphinxhyphen{}sign\_flipping’)

The type of fitting routine used to fit the model. There are two options
designed to explore the sign space of the function.

\sphinxstyleemphasis{Accepted options:}
\begin{description}
\item[{‘qp’ \sphinxhyphen{} Quadratic programming testing every combination of sign}] \leavevmode
on the derivatives. This is a quick process provided the
order of the polynomial is small.

\item[{‘qp\sphinxhyphen{}sign\_flipping’ \sphinxhyphen{} Quadratic Programming testing a sub}] \leavevmode
sample of sign combinations on the derivatives. The
algorithm currently generates a random set of signs for
the \(N-2\) derivatives. It then flips sucessive signs in the
list until it calculates a chi squared smaller than the
previous evaluation of the objective function. For
example a 4th order polynomial has 2 derivatives with \(m>=2\)
which means it has 4 sign combinations {[}1,1{]},{[}\sphinxhyphen{}1,\sphinxhyphen{}1{]},{[}\sphinxhyphen{}1,1{]}
and {[}1,\sphinxhyphen{}1{]}. On first random generation we get {[}\sphinxhyphen{}1,1{]} with
which we evaluate the objective function. We then flip the
first sign and evaluate again with {[}1,1{]}. If the new chi chi squared
is less than the first calculated value the algorithm
then goes back to the original list and flips the second sign
evaluating with {[}\sphinxhyphen{}1,\sphinxhyphen{}1{]}. The process repeats until the new
chi squared is no longer smaller than the previous
evaluation and the previous evaluation is taken to be optimal.
The algorithm then repeats the entire process for a set number
of random sign generations to ensure that the
true minimum is identified. The number of repeats needed
is dependent on the polynomial order. High polynomial
orders require a larger number of repeats to find the true
minimum. Currently the number of repeats is set at
\({2\times(N-2)^2}\).

\end{description}

\sphinxstylestrong{model\_type:} (Default = ‘normalised\_polynomial’)

The type of model used to fit the data. There is a built in library of
maximally smooth functions that can be called by the user.

\sphinxstyleemphasis{Accepted options:}
\begin{quote}

‘normalised\_polynomial’ \sphinxhyphen{} This is a polynomial of the form,
\begin{quote}
\begin{equation*}
\begin{split}{y=y_0 \sum (p_i\bigg(\frac{x}{x_0}\bigg)^i)}.\end{split}
\end{equation*}\end{quote}
\begin{description}
\item[{‘polynomial’ \sphinxhyphen{} This is a polynomial of the form,}] \leavevmode\begin{equation*}
\begin{split}{y=sum(p_i(x)^i)}.\end{split}
\end{equation*}
\item[{‘MSF\_2017\_polynomial’ \sphinxhyphen{} This is a polynomial of the form}] \leavevmode
described in section 4 of
\sphinxhref{https://iopscience.iop.org/article/10.3847/1538-4357/aa69bd/meta}{Sathyanarayana Rao, 2017}

\item[{‘logarithmic\_polynomial’ \sphinxhyphen{} This is a polynomial model}] \leavevmode
similar to that used with the setting ‘polynomial’ but
solved in log\sphinxhyphen{}space. It has the form,
\begin{equation*}
\begin{split}{log_{10}(y)=\sum(p_i(log_{10}(x))^i)}.\end{split}
\end{equation*}
NOTE this model will not work if the y values are negative.

\end{description}
\end{quote}
\begin{description}
\item[{\sphinxstylestrong{base\_dir:} (Default = ‘Fitted\_Output’)}] \leavevmode
This is the directory in which the output of the program is saved. If
the directory does not exist the software will create it in the working
as long as the files that preceed it also exist. When testing multiple
model types it is recommended to include this in the base directory
name eg \sphinxtitleref{self.base\_dir= ‘Data\_Name\_’ + self.model\_type + ‘/’.}

\item[{\sphinxstylestrong{cvxopt\_maxiter:} (Default=1000)}] \leavevmode
The maximum number of iterations for the cvxopt quadratic
programming routine. If cvxopt reaches maxiter the fitting routine
will exit with an error recommending this be increased.

\item[{\sphinxstylestrong{filtering:} (Default=True)}] \leavevmode
Generally for high order N there will be
combinations of sign for which CVXOPT cannot find a solution and
these terminate with the error “Terminated (Singular KKT Matrix)”.
If filtering is set to True these cases will be flagged with a warning
and the corresponding sign combinations will be excluded when
determining the best possible fit. Setting filtering to False will
cause the program to crash with CVXOPT error.

\item[{\sphinxstylestrong{all\_output:} (Default=False)}] \leavevmode
If set to True this will output the results of each run of cvxopt
to the terminal.

\item[{\sphinxstylestrong{ifp:} (Default = False)}] \leavevmode
Setting equal to True allows for inflection points in the m order
derivatives listed in ifp\_derivatives.
\sphinxstyleemphasis{NOTE:} The algorithm will not necessarily return derivatives
\begin{quote}

with inflection points if this is set to True.
\end{quote}

\sphinxstyleemphasis{NOTE:} Allowing for inflection points will increasese run time.

\item[{\sphinxstylestrong{ifp\_list:} (Default = ‘None’)}] \leavevmode
The list of derivatives you wish to allow
to have inflection points in(see ifp above). This should be a list
of derivative orders eg. if I have a fith order
polynomial and I wish to allow the the second derivative to have
an inflection point then ifp\_list={[}2{]}. If I wished to allow the
second and fourth derivative to have inflection points
I would write ifp\_list={[}2,4{]}. Values in ifp\_list cannot exceed the
number of possible derivatives and cannot equal 1.

\item[{\sphinxstylestrong{data\_save:} (Default = True)}] \leavevmode
Setting data\_save to True will save sample
graphs of the derivatives, fit and residuals. The inputs to
produce these graphs are all outputted from the \sphinxstyleemphasis{smooth} function
and they can be reproduced with more specific axis labels/units in
the users code. If filtering is also set to True, which it is by
default, then parameters, objective function values and sign
combinations from each successful run of cvxopt will be saved
to the base directories in seperate folders. The condition on
filtering prevents saving data from runs of cvxopt that did not
find solutions and terminated with a singular KKT matrix.

\end{description}

\end{fulllineitems}



\section{Designing A Basis Function}
\label{\detokenize{source/maxsmooth:designing-a-basis-function}}

\section{Errors and Warnings}
\label{\detokenize{source/maxsmooth:errors-and-warnings}}

\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{m}
\item\relax\sphinxstyleindexentry{maxsmooth.msf}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.msf}}
\item\relax\sphinxstyleindexentry{maxsmooth.settings}\sphinxstyleindexpageref{source/maxsmooth:\detokenize{module-maxsmooth.settings}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}